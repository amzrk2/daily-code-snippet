/**
 * 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树
 * 假设输入的前序遍历和中序遍历的结果中都不含重复的数字
 * 例如输入前序遍历序列 {1, 2, 4, 7, 3, 5, 6, 8} 和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}
 * 
 * 输入：
 * [1,2,3,4,5,6,7],[3,2,4,1,6,5,7]
 * 
 * 输出
 * {1, 2,5, 3,4, 6,7}
 */

const { BinaryTree } = require('./constructor/BinaryTree');

const tree = new BinaryTree([1, 2, 3, 4, 5, 6, 7], [3, 2, 4, 1, 6, 5, 7]);
console.log(tree);

/**
 * 先序数组的首位元素即当前根节点的值（1）
 * 在中序数组中查找当前根节点的值，其左侧即为左子树的节点（324），右侧即为右子树的节点（657）
 * 递归构建左子树，本次先序数组为去除首位元素后和左子树节点个数相同的数组（234）（中序即为324）
 * 递归构建右子树，本次先序数组为去除首位元素和左子树节点后的数组（567）（中序即为657）
 */
